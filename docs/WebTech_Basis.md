**# Web 技術の基本
## Ch.1：Web技術とは
### Web とは
- 正式名称 World Wid Web, 文書を公開・閲覧するためのシステム.
- **ハイパーテキスト**という言語で構成され, **ハイパーリンク**によって世界中のあらゆる Web ページと繋がりを持つ.

### Web の用途
- 文書の閲覧.
  - 1つのドメインの Web ページの集まりを **Webサイト** という.
- 機能とユーザーのやり取りの橋渡しをする**ユーザーインターフェース**を提供.
  - e.g. ユーザーの操作を Webサーバーが代わりにメールサーバーに伝える.
- ソフトウェア同士のやり取りの橋渡しをする **API** を提供.
  - e.g. アプリとWebサーバー間のデータ送受信など.

### HTML とブラウザ
- **HTML** はハイパーテキストを記述するための言語.
  - 表示方法やリンクを**タグ**によって表現するマークアップ言語の一種.
- **Webブラウザ** は HTML を解釈して, わかりやすく作り変えるためのプログラム.

### Webサーバーと HTTP
- **Webサーバー**は, Webブラウザからコンテンツの要求があった場合に, 必要なコンテンツ（ハイパーテキスト）を返すためのプログラム.
  - 「持っていない」という情報や, 別の Webサーバーへの案内といった情報を返すことも可能.
- コンテンツのやり取りに関する手順や送受信するメッセージの書式は **HTTP** という仕様で定義されている.
  - 世界標準であるため, どの企業のどんなブラウザ・Webサーバーでも同じ手順で Webサーバーとのやり取りが可能になっている.

### Webページ
- Webページを取得するには **URL** を指定することがスタートとなる.
  - URL には「どのやり取りの手順で」「どの Webサーバーに」「何のコンテンツを」取得するか, が情報として含まれている.
    - どのやり取りの手順で：http または https
    - どの Webサーバーに：ドメイン
    - 何のコンテンツを：HTML や画像など
  - URL をもとにコンテンツの取得を繰り返していくことで, ユーザーは要求した Webページを閲覧できるようになる.
- Web ページには, **静的ページ**と**動的ページ**の2種類がある.
  - 静的ページ：アクセスのたびに同じコンテンツが表示される Webページ.
  - 動的ページ：アクセスしたときの状況に応じて異なるコンテンツが表示される Webページ.
    - Webブラウザの要求に応じてプログラムが作動しており, それを作動させる仕組みを **GCI** という.
    - したがって, 動的ページでは URL は GCI が用意された場所を示す.
      - GCI から呼び出され, 作動するプログラムは**サーバーサイド・スクリプト**といい, Perl や Python, PHP, JavaScript などの**スクリプト言語**で記述される.
      - 一方で, HTML に埋め込まれ, ブラウザ上で作動するプログラムは**クライアントサイド・スクリプト**といい, 主に JavaScript が該当する.

### Web の標準化と設計思想
- HTML や CSS, XML などは **W3C**（HTML のみ **WHATWG**）によって**標準化**されている, すなわち一定の規格が定められている.
  - これは言語の機能拡張が個々に広がると, 「どの Webブラウザでも, ほぼ同じように Webページが表示される」という状態が実現しづらくなるからである.
- 標準化されたもの以外にも, Web にはある一定の設計思想がある.
  - **RESTful** なシステム
    - 統一インターフェース：予め定義された方法で, 情報をやり取りする（HTTP など）.
    - アドレス可能性：すべての情報が一意な URL で表される.
    - 接続性：やり取りされる情報の中にはリンクを含めることができる.
    - ステートレス性：やり取りは1回ごとに完結し, 以前のやり取りの結果に依存しない.
  - **セマンティック Web**
    - XML　により, テキストが属性などの**メタデータ**を持つことで, 検索可能精度を大幅に高める Web の構造.
    - ただし, メタデータの付与の膨大さがボトルネックとなり, なかなか普及しない.

## Ch.2：Web とネットワーク技術
### コンピーターネットワーク
- コンピューターが互いに接続して情報のやり取りをするネットワークの中で, コンピューターは以下の2つに大別される.
  - **サーバー**：ネットワーク上で情報・サービスを提供する.
  - **クライアント**：サーバーから提供された情報・サービスを利用する.
- 自宅や会社などの小規模なコンピューターネットワークを互いに繋ぐのがインターネットである.
  - インターネットはプロバイダ（ISP）によって提供される.
  - ISP 同士が階層構造を持って繋がる（IX）ことで, 世界中のサーバー・クライアントと通信が可能になっている.

### 標準プロトコル
- **プロトコル**：ネットワークに接続された機器同士が通信するときの共通のルール・手順.
- **TCP/IP** はあらゆる機器があらゆる機器と通信できるという意味で, 標準のプロトコル群として利用されている.
  - **アプリケーション層**：クライアントとサーバーのやり取り規定し, ネットワークに適した形へデータを変換する役割を担う. e.g. HTTP, FTP など.
  - トランスポート層：データ分割やデータ品質の保証を規定する. e.g. TCP, UDP.
  - インターネット層：ネットワーク化の通信を規定する. e.g. IP, ICMP など.
  - ネットワークインターフェース層：ハードウェアに関する規定. e.g. Wi-Fi など.
- たとえば, ブラウザからサーバーにデータを要求した際には, 下層に行くにつれて規定に則ったヘッダーが追加され（カプセル化）, 上層に行くにつれてそのヘッダーが除去されていく（非カプセル化）ことで応答を行っている. 

### IPアドレス
- **IPアドレス**：インターネットに接続されたコンピューターを特定し, データの行き先を管理する.
  - ところが, IPアドレスだけでは Webサービスなのかメールサービスなのかというコンピューターの提供するサービスまでは分からない
  - これを補完するのが, **ポート番号**であり, これによって特定のコンピューターの特定のサービスを受けることが可能になっている.

### URL とドメイン
- URL に関しては, Chapter.1 に記載した通り.
- ただし, 認識性の問題から IPアドレスの代わりに**ドメイン**を使用している.
  - 一般にIPアドレスによって通信先を特定するため, ドメインは IPアドレスに変換可能である.
  - これを可能とするのが **DNS** という仕組みであり, これを提供するのが **DNSサーバー**と呼ばれる階層型のコンピューター群である.

## Ch.3：HTTP の仕組み
### HTTPメッセージ
- HTTP はクライアントである Webブラウザと, サーバーである Webサーバー間のやり取りをするが, そのやり取りで利用されるのが **HTTPメッセージ**である.
  - HTTPメッセージは, Webブラウザからの要求としての **HTTPリクエスト**と, Webサーバーからの応答である **HTTPレスポンス**に大別される.

### HTTPリクエストと HTTPレスポンス
#### HTTPリクエスト
- HTTP リクエストの構成
  - リクエスト行：Webサーバーに対する「（サーバーが持つ）どのデータに」「どのような処理がしたいか」の要求内容.
  - メッセージヘッダー：Webブラウザやバージョン, 対応可能なデータタイプなどの付加的な情報.
  - メッセージボディ：Webブラウザのフォームなど, 入力された内容.
- 要求の具体的な内容は **HTTPメソッド**によって, リクエスト行に記述される. Web サイトで主に利用されるのは以下の2つ.
    - **GET**メソッド：コンテンツの取得を取得する. データ送信には機密性の低い URLパラメータを利用する.
    - **POST**メソッド：データを Webサーバーに送信する. GET とは異なり, メッセージボディにデータが組み込まれるため, データ送信の機密性が高い.

#### HTTPレスポンス
- HTTPレスポンスの構成
  - ステータス行：HTTPリクエストに対する, Webサーバー内の処理結果.
  - メッセージヘッダー：Webサーバーの種類や, 送信するデータ形式などの付加情報.
  - メッセージボディ：クライアントから要求された HTML ファイルや画像などのデータ.
- 要求に対する処理結果は **ステータスコード**によって, ステータス行に記述される. ステータスコードは5つに分類される.
    - 100番台：HTTPリクエストが処理中であることの通知.
    - 200番台：HTTPリクエストに対して, 正常に処理が完了したことを通知.
    - 300番台：HTTPリクエストに対して, 転送やリダイレクトなど Webブラウザ側で追加処理が必要なことを通知する.
    - 400番台：リクエストが不正であったり, リクエスト対象が存在しないことを示すクライアント側のエラー通知.
    - 500番台：高負荷などのサーバー側のエラー通知.

#### メッセージヘッダー
- HTTPリクエスト・HTTPレスポンスの双方に含まれる HTTPメッセージに関する詳細な情報.
  - 一般ヘッダーフィールド：HTTPメッセージの作成日時など.
  - リクエストヘッダーフィールド：リクエスト先のサーバー名やリファラー, Webブラウザの固有情報など.
  - レスポンスヘッダーフィールド：リダイレクト先の Webページの情報や, Webサーバーの固有情報など.
  - エンティティヘッダーフィールド：メッセージボディ内のデータタイプやサイズ, 有効期限などコンテンツに関わる固有情報など.

### TCP によるデータ通信
- HTTPリクエストと HTTPレスポンスにおけるデータの役割を担うのが TCP である.
- クライアントとサーバ間で通信可能なのかを確認する**コネクション**という通信経路を確立した上で, 実際のデータのやり取りを行う. コネクションを確立するための手順は以下.
  - クライアントからサーバーに対して, **SYNパケット**を送信する.  
  - サーバーが SYKパケットに応答して, 次はサーバーから SYKパケット + **ACKパケット**を送信する.
  - クライアントが送信されてきた SYKパケットに対して ACKパケットを送信する.

### HTTPのやりとり
#### HTTP/1.1
- HTTP/1.0 以前では1回のリクエストごとにコネクションを接続し, レスポンスがあると切断していた.
  - それでは複数のリクエストに対して効率が悪いため, コネクションを継続する **HTTPキープアライブ**という方式が, HTTP/1.0 から採用されている.
- また, 複数のリクエストを効率的に処理するために, 他処理のレスポンスを待たずに他のリクエストを送信する **HTTPパイプライン**が確立された.

#### HTTP/2
- さらなる効率化を目指し, Google が提案した SPDY というプロトコルをベースにいくつかの改良がなされた.
  - **HTTPストリーム**：HTTPパイプラインの「レスポンスの順番はリクエストの順番に従う」という弱点を改善したもの. 各リクエストにストリームが割り当てられ, レスポンスは早く処理が終わった順に返される.
  - テキスト形式からバイナリ形式へ：テキストデータの変換処理にかかる時間の短縮を可能とする.
  - メッセージヘッダーの圧縮：異なるリクエスト間で, 同じ情報を HPACK と呼ばれる方式で圧縮することで, 送受信するデータ量を差分だけに削減することを可能とする.
  - サーバープッシュ：コンテンツを表示するのに必要な他コンテンツをリクエストすることなく, サーバー側から提案し, 自動で送信すること.

### HTTPS
- HTTP の通信において, **SSL** や **TLS** と呼ばれる暗号化方式を組み合わせることでセキュリティを高めたのが **HTTPS** である.
  - 暗号化通信：第三者からの盗聴を防ぐ.
  - 改竄防止：データの送受信時にそのハッシュ値（**メッセージダイジェスト**）を取得することで, 改竄を検知することが可能.
  - なりすまし防止：Webサーバーに設置された **SSLサーバー証明書**を検証することで, 信頼された**認証局**によって認証された運営元かを特定できる.
- TCP のコネクションが確立された後, 以下のような手順（**SSL/TLS ハンドシェイク**）を踏むことで HTTPS通信が開始される.
  - 暗号化方式の決定：クライアントとサーバー間で利用可能な暗号化方式・メッセージダイジェストのスキーマなどが定められる.
  - 通信相手の証明：正しい Webサーバーであるのかを, SSLサーバー証明書によって確認する.
  - 鍵の交換：送信の暗号化および暗号化されたデータを復号するための鍵をクライアントとサーバー間で交換する.
  - 暗号化方式の確認：クライアントとサーバーの間で利用する暗号化方式の最終確認作業を行う.

### ステートレスとステートフル
- **ステートレス**：リクエストとレスポンスの1往復が独立して, 他のやり取りに依存しない設計のこと
- **ステートフル**：前回以前のリクエストとレスポンスの結果が, 次回以降のリクエストとレスポンスの処理に影響する設計のこと.
- HTTP は負荷を避けるため, ステートレスな設計になっているが, 近年の Webサービスの複雑化により, クライアントごとに以前の状態を保持する必要性も出てきた. e.g. ショッピングサイトの買い物カゴなど.
  - これを補完するのが **Cookie** である.
    - Web サーバーがコンテンツと一緒に, 接続してきた Webブラウザを識別するための情報（Cookie）を送信し, それを Webブラウザに保存することで, 接続相手を識別することが可能になる.
    - レスポンスのメッセージヘッダーに**Set-Cookieヘッダー**を, リクエストのメッセージヘッダーに**Cookieヘッダー**を記述することで, Cookie 情報を送受信している.
    - Cookie の種類.
      - セッション Cookie：有効期限が設定されておらず, ブラウザが閉じると同時に削除される Cookie.
      - non セッション Cookie：有効期限が来るまで, ブラウザを閉じようが残り続ける Cookie.

### セッション
- クライアントとサーバーの間における一連のやり取りのこと.
- あるブラウザからの処理を関連性のある一連の処理として扱う場合は Cookie を用いてセッションを管理できる.
  - Web ブラウザを識別する情報を **セッションID** といい, サーバーで生成され, 一般には Cookie に含めてブラウザに送信される.
  - これによって, 各クライアントがセッションID を渡すだけで, 自分の過去の処理に応じた情報にアクセスできるようになる.

### URI とは
- **URI**：情報やデータといったリソースを識別するための記述方法.
  - **URL**：リソースの場所を表す.
  - **UTN**：リソースの名前を表す.
- HTTP リクエストで, 各メソッドで操作したいリソースを特定するのにも URI が利用され, それらは特にリクエストメソッドに続いて記述されることから, **リクエストURI** と呼ばれる.
  - **絶対URI形式**と**相対URI形式**があり, 通常は後者が利用される.
- URI では特定の予約文字しか使えないため, 非予約文字はパーセントエンコーディングによって予約文字化される.

## Ch.4：Web のさまざまなデータ形式
### HTML
- タグに囲まれた文章によって構成される言語.
- **開始タグ**, 文章, **終了タグ**で成る塊を**要素**といい, それが何を示すかは**要素名**という.
- タグには**属性（Attribute）**が追加でき, リンクや引数を指定できる.

### 画像形式
- **JPEG**
  - 拡張子は .jpg や .jpeg.
  - 1677万色を扱い, 写真データなどに有用だが, データ圧縮による画質の劣化が激しい.
- **GIF**
  - 拡張子は .gif.
  - 256色しか扱えないが, アニメーションが可能であったり, 圧縮による劣化が起こらないなどの特徴がある.
- **PNG**
  - 拡張子は .png.
  - 1677万色扱え, 圧縮による劣化も起きず, GIFよりもデータサイズが小さい.
  - また, 透明度を扱うことができることも特徴.

### XML
- HTML と同じ親である **SGML** から派生したマークアップ言語.
- タグを自由に定義することができ, クライアントとサーバー間でデータのやり取りをする際にデータを構造化することを目的に利用されている.

### XHTML
- HTML を XML 文法で再定義したもの.
- XML を埋め込める特徴があり, **MathML** や **SVG** を活用できることが特徴.

### CSS
- HTML や XML の表示方法（体裁）を表現する言語.
- デバイスなどクライアントの種類によって, CSS を別に用意することができる.

### スクリプト言語
- 動的処理に使用される言語.
  - サーバーサイド・スクリプトは CGI から呼び出すため, HTML と分離している.
  - クライアントサイド・スクリプトは HTML に埋め込むことも可能だが, 一般に分離されている.
- **ECMAScript**
  - **JavaScript** を指し, 2社が開発していた類似言語を一定の規格で統一したもの.
  - Webブラウザに対する汎用性が高いことから, クライアントサイド・スクリプトとして活躍してきたが, 近年ではサーバーサイド・スクリプトとしての活躍の場も増えている.
- **Perl**
  - 文法の自由度が高いサーバーサイド・スクリプト.
- **Python**
  - スクリプトの可読性が高いサーバーサイド・スクリプト.
- **PHP**
  - CGI を介さずに, HTMLに埋め込んで使用できるサーバーサイド・スクリプト.
- **Ruby**
  - オブジェクト指向プログラミングに向いたサーバーサイド・スクリプト.

### DOM とは
- HTML や XML を扱うための手法（API）.
- クライアントサイド・スクリプトやブラウザの機能などのプログラムから HTML にアクセスするときに, DOM を介することでタグの情報から HTML を辿って文章を取得することができる.
- HTML のタグの階層構造をそのまま **DOMツリー**という形で扱い, ノードを辿ることであらゆる文書への参照を可能としている.

### JSON とは
- 構造化したデータを表すためのデータ記述言語の一種.
- 同じデータを木構造で表現できる XML と比べて...
  - JSON は数値や空データも扱うことができる.
  - JSON はデータを括弧で囲むだけなので（入れ子で階層）, データ量が小さい.
  - JSON は文書ではなく, JavaScript の書式に従っているため, DOM を経由する必要がない.
  - したがって, JSON は Webの世界で扱われることが多い.

### フィード
- Web サイトの更新履歴を配信するためのファイルで, ユーザーはフィードを取り込むことで Webサイトを訪れることなく最新の更新情報を閲覧できる.
  - **RSS**, **Atom**：代表的なフィード.
- Web 上のフィードを取得し, 管理するためのソフトウェアとして, **フィードリーダー**がある.
  - 複数の登録されたふぃーどを定期的にチェックして, 更新情報をユーザーがチェックできるように表示する機能を搭載している.
- Webサーバー上に音楽や動画ファイルを配置し, RSS を通して公開する**ポッドキャスト**という手法もある.
  - RSS は新しい放送を通知するために利用されている.

### マイクロフォーマット
- セマンティックWeb を実現するために, HTML の class要素などに各要素の意味（メタデータ）を埋め込む書式.
- e.g. この文字列は電話番号を表している, など.

### 音声・動画配信
- 音声や動画などは画像と同様, 通信速度高速化のために**エンコード**（圧縮）と**デコード**（伸張）といった処理が**コーデック**というソフトウェアで行われている.
  - エンコードによってアップロードされ, デコードによって再生される.
- 配信形式
  - **ダウンロード配信**：Webサーバーからダウンロードしてもらって, 終了後はいつでも再生できる形式.
  - **プログレッシブダウンロード配信**：ダウンロード中でもダウンロードした分までは再生できる形式.
  - **ストリーミング配信**：ファイルを細分化し, 個々をダウンロードしつつ, 再生した分は削除する形式. データが残らないため, 著作権の問題もクリアしやすい.

### メディアタイプ
- レスポンシブデザインのために, 様々な機器を**メディアタイプ**を通して HTML, CSS で指定できる.


## Ch.5：Webアプリの基本
### Web アプリケーションの3層アーキテクチャ
- **Webアプリケーション**とは, ネットワークを介して, webブラウザ上で動作するアプリケーション.
- 以下の3層構造となっていることが多い.
  - **プレゼンテーション層**
    - Web ブラウザと Webサーバーが役割を持つ. 
    - ユーザーインターフェース（表示や操作受付）となり, クライアントサイド・スクリプトが動作する層.
  - **アプリケーション層**
    - APサーバーが役割を持つ.
    - 業務処理（要求実行や画面生成）を行い, サーバーサイド・スクリプトが動作する層.
  - **データ層**
    - DBサーバーが役割を持つ.
    - データ処理や保管, 更新を行う層.
- 3層に分けるメリットとは何か?
  - 処理能力の長所短所を互いに補い合うことで, **負荷分散**を行える.
  - 改修範囲を小さくできる.

### MVCモデル
- サーバーサイド・スクリプト（AP層とデータ層）の設計思想の1つであり,
  - **Model** によって, データと業務の処理を,
  - **View** によって, ユーザーへの出力を,
  - **Controller** によって, 必要な処理を Model と View へ伝える.
- 機能ごとに役割が分かれるため, 改修範囲の狭小化や特定のしやすさなどの点でメリットがある.

### フレームワーク
- Web システムのプログラムの処理の流れには大まかな共通な流れがある.
  - e.g. クライアントからデータを受け取り, DB からデータを取得し, 結果を画面に表示する, といった具合に.
- このような一般的な流れをひな型として準備したものが**フレームワーク**であり, 開発者は一定の品質の担保と開発スピード向上というメリットを享受できる.
  - e.g. Java EE, Struts, Spring Boot, Cake PHP, Ruby on Rails など

### Webサーバー
- クライアントからの要求の窓口的な役割を果たす.
  - 静的ページであれば, サーバー内からコンテンツを探し,
  - 動的ページであれば, アプリケーション層に動的処理を命令し,
  - 処理や検索が終われば, その結果をクライアントへ表示する.
- 1つの Webサーバーに不具合があっても動作するように, またマシンへの負荷を減らすために, 複数のマシンで運用する**冗長化**が一般的である.

### Webクライアント
- Webサーバーとやり取りを行い, Webシステムを利用するためのプログラムであり, ユーザーの操作をもとに Webサーバーへリクエストを送り, 帰ってきたレスポンスを解釈しやすい形に変えることが基本的な機能.
- Webブラウザが代表的だが, 専用ブラウザやスマートフォンアプリなど, 各々の機能に特化した性能を持つ専用クライアントも続々と登場している.

### アプリケーション・サーバー
- Webサーバーからの動的処理命令に対して, サーバーサイド・スクリプトを実行しデータ処理などを行って, 再び結果を Webサーバーに返す役割を持つ.
- APサーバーは**セッションID** を通信データに含めることで, 同じクライアントからの通信を**セッション**という形で1まとめにする.
  - e.g. ログインからログアウトまでの間を1セッションとして, 特定のクライアントの操作をセッション内でそれぞれ紐づける.
- セッション内での一連の作業の最小単位を**トランザクション**という.
  - APサーバーは任意の範囲で設定されたトランザクションを管理する機能も持つ.

### データベース管理システム
- APサーバーからの命令を受けてデータの格納が行われる**データベース（DB）**, それを管理する役割として**データベース管理システム（DBMS）**が存在する.
- 一般に, DBMS を搭載したサーバーを **DBサーバー**という.
- DBの保全は最重要事項であり, ここでも**冗長化**が行われている.
  - **ミラーリング**：APサーバーとやり取りをするプリンシパルサーバーが存在し, プリンシパルからミラーに更新命令が転送される.
  - **レプリケーション**：APサーバーとやり取りをするマスタサーバーが存在し, マスタからスレーブに更新履歴が送信される. ミーらリングと異なり, スレーブは即時更新されるわけではない.
  - **シェアードディスク**：共用のデータストレージを持つ DBMSを複数用意する構成.

### キャッシュサーバー
- リクエストの肥大化に伴う Webサーバーや DBMS への負荷を減らすために, 「子のリクエストに対するレスポンスを覚えておく（**キャッシュ**）」役割を実現する**キャッシュサーバー**がある.
  - **コンテンツキャッシュ**：文書や画像, 動画といったコンテンツに関するキャッシュ.
  - **クエリキャッシュ**：DBMS のデータ検索結果に関するキャッシュ.
- つまり, キャッシュサーバーは特定の繰り返されやすいリクエストに対して, Webサーバーや DBMSの高速の代行をすることになる.
- ただし, キャッシュには有効期限があるため, 必要に応じてキャッシュサーバーの内容を更新しておくことが必要になる.
- また, 複数のコンテンツキャッシュサーバーに定期的に Webサーバーからキャッシュを取得することで, コンテンツ表示の高速化を図る **CDN** とういうシステムもある
  - 実際にレスポンスを返すのはクライアントから最も近いキャッシュサーバーである.

### Ajax
- 従来コンテンツを変更するには, Webサーバーを介したリクエストとレスポンスの往復が必要な**同期通信**が一般的だった.
- 同期通信の負荷性と速度の弱点を克服すべく, **Ajax** が登場した.
  - Ajax はブラウザ上で, クライアントサイド・スクリプトとして動く JavaScript が Webサーバーと直接通信を行い, コンテンツを更新することで, 高速化を実現している.
  - また, DOM を用いた命令を行うために該当部分だけのデータ量で済むという利点もある.
  - さらに, レスポンスを待つ間にも JavaScript が独立して更新を続けることができる**非同期通信**も可能であるため, Webページの高速化が実現されている.

### Webプログラミング
- **サーバーサイド・プログラム**
  - APサーバー上で動くものをプログラムする.
  - リクエストや DB の処理速度や, セキュリティの高さが求められる.
- **クライアントサイド・プログラム**
  - Webブラウザ上で動くものをプログラムする.
    - ブラウザごとの動作の違いへの対応力や非同期通信の複雑さへの適応が求められる.

### Web API
- ユーザーが操作せずとも, アプリケーション層のプログラムから別サーバーへデータをリクエストし, レスポンスを返してもらう仕組みを **Web API** という.
- 具体的には URL を利用してデータを送信することで, ユーザーの操作関係なく結果を得ることができる.
- このようなプログラム同士のデータのやり取りには様々な方式があるが, 現在主流なのは SOAP あるいは REST である.

### マッシュアップ
- Web API によって, 複数の Webサービスを組み合わせて新しい Webサービスを作り出す**マッシュアップ**が可能になった.
- ただし, API の仕様変更や利用停止には十分留意する必要がある.

### CGI
- Webサーバーがクライアントからの要求に応じて, サーバーサイド・スクリプトを実行するための仕組み.
- CGI 用のプログラムへ要求が来た場合は即時にレスポンスを返さず, 実行結果を取得してからそれを返す仕組みになっている.
  - これはクライアントが CGI の URL にアクセスすることがトリガーとなっている.
  - クライアントがデータを渡す方法は以下の2つ.
    - **コマンドライン引数渡し**：URLの末尾に?をつけることで, Webサーバーが CGI にデータを渡す.
    - **パス渡し**：URL の末尾で, /で区切ることでデータを渡す. Web サーバではなく, メッセージの PATH_INFO からデータを取り出す.
    - GETメソッド
    - POSTメソッド

### サーバー間の連携
- CGI を用いずにサーバーサイド・スクリプトを実行させる手段として, Webサーバーが APサーバーにデータ処理を依頼し, APサーバーがスクリプトを実行する流れになる.
  - このような場合は, webサーバーがクライアントに, APサーバーがサーバーとなる.
  - このときに利用するプロトコルは **AJP** や **WebSocket** が利用されている.

## Ch.6 Web のセキュリティと認証
### セキュリティ対策
- **情報セキュリティの3要素**
  - **機密性**：アクセス許可を持つ者だけがアクセスできること.
  - **完全性**：情報が破壊・改竄・消去されていない状態を確保すること.
  - **可用性**：必要な時はいつでも情報にアクセスできること.
- 情報セキュリティが維持できず, 損失が発生する可能性を**リスク**という.
  - リスクを現実化する要因を**脅威**（不正アクセスなど）, 脅威に対する弱みが**脆弱性**（バグなど）である.
- したがって, リスクを**顕在化**させないために, 脅威や脆弱性を洗い出す必要がある.

### 様々な攻撃方法
#### パスワードクラッキング
- 個人情報を狙い, Iパスを抜き出そうとする攻撃.
  - 対策：パスワードの堅牢性を高める作りが必要.
- **辞書攻撃**：多用されるパスワードを辞書ファイルに用意しておき, それによってパスワードを当てる方法.
- **ブルートフォース攻撃**：しらみつぶしに文字の全組み合わせを試す方法.

#### DoS攻撃
- 短時間にサーバーが処理しきれない大量のアクセスを行って, サービスを停止状態に陥らせる攻撃.
  - 多数のクライアントによって1つのサーバーを集中攻撃する **DDoS攻撃**というものもある.
  - 対策：攻撃元のIPアドレスを特定し, 遮断することが必要.
- **SYN Flood攻撃**：TCP における SYNパケットのみを大量に送り付けて, サーバーを接続待ちにさせる攻撃.
- **F5攻撃**：アクセスを繰り返し, リクエストが反応できなくなるまでサーバーの負荷を高める攻撃.

#### セッションハイジャック
- セッションIDを盗聴し, ログイン済みユーザーとして入り込み, 個人情報を不正に取得する攻撃.
  - 対策：同じセッションID でも, 異なるIPアドレスからのアクセスであれば, 強制的にログアウトさせる仕組みなどが必要.

#### ディレクトリトラバーサル
- ディレクトリ移動のコマンドを悪用し, Web で公開されていないディレクトリにアクセスすることで, Webサーバー自体のパスワードなどを取得する攻撃.
  - 対策：リクエストに含まれるURLのチェックを行い, 未公開ファイルが指定されていないかを確認することが必要.

#### クロスサイトスクリプティング（XSS）
- 攻撃者が「脆弱性を持つ Webサイトに対してスクリプトを書き込む」リンクを表示する Webページを公開する.
- そのリンクにユーザーがアクセスすることで, クライアントサイド・スクリプトが実行され, 掲示板サイトなどに意図せず悪意のあるスクリプトを書き込んでしまう.
- 多数のユーザーがそれを閲覧することで, スクリプトが実行され, Cookie 情報の抜き取りや, ウイルスのダウンロードが行われる.

#### クロスサイトリクエストフォージェリ（CSRF）
- XSS と同様にクライアントサイド・スクリプトが実行され, ログイン状態のまま意図しない操作を行わせる攻撃.
- 所謂なりすましで, パスワードの改竄や XSS 用のリンクを広く SNS 等で拡散させることなどが2次攻撃手段となる.

#### SQLインジェクション
- 入力フォームなどに SQL を記述することで, DB サーバーへ不正な操作を行う攻撃.

### Webシステムの脆弱性
- 脆弱性を完全になくすことは難しく, 特に避けられないのが**セキュリティホール**である.
  - ソフトウェアの欠陥によって, 権限が必要な操作が権限を持たないユーザーにも実行できてしまったり, 見えるべきではない情報が第三者からも見えてしまう不具合のこと.
- 発見されたセキュリティホールは, **脆弱性情報データベース**に管理される.
  - システム管理者は, これによりセキュリティホールの確認ができる.
  - ソフトウェア開発者は, 修正プログラム（パッチ）を配布することで対応する.
- ただし, セキュリティホールに対するパッチが開発される前に攻撃を仕掛ける**ゼロデイ攻撃**は最も対策が難しい攻撃となっている.

### ファイアウォール
- 攻撃への対策として, アクセスを完全に遮断するわけではなく, サービスに必要な通信だけを許可し, それ以外の通信を拒否する方式が一般的である.
- このとき, アクセスの許可・拒否を行う役割を果たすのが**ファイアウォール**である.
- **パケットフィルタ型ファイアウォール**
  - 送受信するデータの IPアドレスとポート番号をチェックし, アクセスの拒否・許可を行う最も一般的な方式.
  - e.g. 社内ネットワークであれば, 社内の IPアドレスさえ許可を出しておけば外部からのアクセスは拒否できる.
  - e.g. 不特定多数向きのサービスであれば, Web サーバーだけへアクセス許可を出しておけば, DBサーバーやAPサーバーへの不正アクセスをなくすことができる.

### IDS, IPS
- ファイアウォールで防ぎきれない攻撃を防ぐ方法の1つ.
- 通信を監視（して異常値を検知）するネットワーク型と, サーバー上のユーザーの動きを監視するホスト型がある.
  - IDS はシステム管理者への通知のみだが, IPS はそれに加えてアクセスを自動的に遮断する.
  - 一方で, IPS は誤検知が発生してしまうと可用性が低くなってしまう.
- 検知方法には以下の2つがある.
  - **シグネチャ型（不正検知型）**：既知の攻撃手段における通信パターンを記録した DB と照合して, 一致する場合に不正アクセスとして検知する.
  - **アノマリー型（異常検知型）**：普段の通信と比べて異なるパターンの通信や, 通常は発生しない通信パターンが発生した場合に検知する.

### WAF
- IDS や IPS は通信パターンの異常を見るためのものなので, 通信の中身に関する攻撃（XSS や SQLインジェクションなど）までは防ぐことができない.
- 基本的には WEbアプリケーション側で事前対応しておく必要があるが, パケットの中身をチェックする**WAF**という手段もある（ただし, コストが非常に高い）.
- WAF には以下の2つの方式がある.
  - **ブラックリスト型**：シグネチャ型のように, 特定のパターンに該当する通信内容を遮断する.
  - **ホワイトリスト型**：正常なデータのパターンに合致する通信内容のみを許可する.

### 暗号化
- **通信の傍受**や**不正侵入**に備えて, **暗号化**を対策として打っておく必要がある.
  - **暗号化**：元のデータ（**平文**）を暗号化の手段（**暗号化アルゴリズム**）によって, 第三者が読み取れないデータ（**暗号文**）に変換すること. 暗号文を利用するには平文に戻す（**復号**）必要がある.
- 通信経路での暗号化
  - ユーザーと Webサーバーでのやり取りにおいて, HTTPS などで暗号化することで, 通信の間のIパスなどを傍受できなくする.
- 保存データの暗号化
  - Webサーバーから DBサーバーへデータを保存する際に**ハッシュ関数**をなどを用いて**ハッシュ値**に変換（**ハッシュ化**）することで, 不正侵入しても元のデータを取り出せないようにする.

### 公開鍵証明書
- 機密情報を扱うが, 顔の見えない相手とのやり取りおいては, **アクセスしている Webサイトが本物かどうか**を, 如何に確認するかが肝要となる.
- その証明方法が**公開鍵証明書（SSL証明書）**であり, 認証局という機関から発行されている.
  - HTTP 通信に使うための公開鍵の持ち主が誰であるかを証明すること.
  - 公開鍵の持ち主が実在することを証明すること（実在証明）.
- 暗号化通信を行った際に, 暗号化に使用した公開鍵に関する公開鍵証明書が返ってくれば, そのサイトは本物であると判断することができる.
- 一方で, 身内で試験的に公開鍵証明書を利用する場合は, 自身が認証局となって発行できる自己証明書というものもある.

### 認証
- ID を用いてログインを行い, 本人確認を行う処理のこと.
- しかし, 近年は Webサービスの多様化によって, ユーザーの ID管理に関わる負担が増えてきた.
- そこで, Google や Facebook などの利用者が多いサービスが管理しているアカウント情報で認証を行える仕組みができてきた.
  - **認証API**方式：API から返ってきた認証結果をもとにログイン情報を扱うことができる. が, 認証元のアカウントを持っていないと認証できない, API の仕様が統一されていないという問題がある.
  - **OpenID** 方式：認証API 方式の問題を解消し, 認証処理を標準化したプロトコル.

### 認可
- 認証で確認した結果によって, ユーザーごとに権限に従って利用できるサービスの許可を行うこと.
  - e.g. Twitter において「taro」というユーザーが認証されたとき, 「taro」名義のアカウントでは投稿や編集を可能とするが, そのほかのユーザーに対しては閲覧のみを許可する.
- 近年ではアプリからのシェアなど, 複数のサービスを跨いだ認可が必要となってきている. 
  - **OAuth**：サイトを跨いだ認可を実現するための標準プロトコル.
    - 跨ぎ先のサービスは**リソース**, それを提供するサーバーを**リソースサーバー**, そのユーザーを**リソースオーナー**, 認可を受けてリソースを利用するサーバーをクライアントという.
    - クライアントがリソースを利用する際には, リソースオーナーに許可を要求した後, リソースサーバーに**トークン**の発行を依頼する.
    - 許可の正当性が認められれば, トークンが発行され, そのトークンを用いてクライアントはリソースにアクセスすることができる.
  - **OpenID Connect**
    - OAuth 2.0 をベースに認証機能を追加したプロトコル
    - 認証機能を備えているため, OAuth のように別の認証方法を利用する必要がないメリットがある.

### CAPTCHA
- 自動投票プログラムなど, プログラムを用いた Webサービスの悪用を防ぐ目的で考案されたのが, **CAPTCHA**である.
  - 悪用される可能性のある捜査の直前に, 「操作が人間の手によるものであるのか」を複雑な操作を要求することで判別する.
  - パズルピースのはめ込みや, 写真の識別などパターンは様々.

## Ch.7 Webシステムの構築と運用
### 提供するサービスの検討
- Webシステムを構築する際に最初に始めるべき検討.
- **サービスの内容**
  - 何を提供するのか, 誰に提供するのか, など.
- **アプリケーションに必要な機能・デザイン**
  - 外部サービスが必要なら, それと連携する API が必要.
- **システム基盤に求められる機能**
  - データベースが必要なシステムでは DBサーバーが必要になったり, 子新情報を扱うのであればセキュリティを高める機器が必要になったり, など.

### 利用言語, ソフトウェアの検討
- **プログラミング言語**
  - アプリケーションの特徴にあった言語, フレームワークの選定が肝要.
- **サーバーの OS**
  - アプリケーションを動作させるサーバーの OS. 基本的には Windows か Linux となる.
- **ミドルウェア**
  - OS とアプリケーションの中間に位置するプログラム.
    - Web サーバーや APサーバー, DBMS などが該当.

### ネットワーク構成の検討
- システムの用途やセキュリティレベルなどによって構成は異なってくる.
- ネットワークを分割することによって, インターネットから直接内部のデータなどにアクセスすることを防ぐことができる.
  - **外部ネットワーク**：インターネットに晒されるネットワーク. ファイアウォールの外側.
  - **内部ネットワーク**：インターネットと隔離されたネットワーク. AP サーバーや DBサーバーがよく置かれる.
  - **DMZ**：内部ネットワークと外部ネットワークの折衝を行うネットワーク. IDS や IPS, WAF, Web サーバーなどが置かれ, 内外ともに通信にファイアウォールを仲介する.
- さらに耐障害性を高めるためにネットワークの冗長化も一考の余地あり.

### サーバー構成の検討
- どのサーバー機器で動作させるか, サーバー機器の配置先のネットワークをどこにするか, サーバーの冗長化を行うか, などを決める.
- 冗長化を検討する場合, システムに届くリクエストをどの Webサーバーに渡すか, この振り分け作業を行う機器を**ロードバランサー**という.
  - ロードバランサーは Webサーバーより, インターネット寄りに置かれ, 受け取ったリクエストを複数の Webサーバーに均等に振り分ける.
  - また, レスポンスもロードバランサーを仲介してクライアントに返送する.
- コストと可用性のトレードオフの関係の中でサービスにとって最適なサーバー構成をする必要がある.
  - コスト重視なら, 1つの機器で Webサーバーと APサーバーを動かして DMZ に置くなど.
  - 可用性重視なら, Web サーバーを冗長化して DMZ に置き, APサーバーと DBMS も両方冗長化して内部ネットワークに置くなど.

### サーバー基盤の検討
- 基本的には自分でサーバー機器を購入するか, 他人から借りるか, になる.
- **オンプレミス**
  - 自社運用のことであり, 機器の構成の自由度やデータの所在の検索性の高さなどがメリットだが, 投資コストや運用コストが高いのが難点.
- **レンタルサーバー**
  - 他者が構築しているサーバーを間借りする方式. コストはかかりにくいが, 自由度はほとんどない.
- **クラウド**
  - 他者が提供する仮想的なサーバーを設置できる環境のこと.
  - その中に自分たちでサーバーを設置することができ, 初期投資コストも低いながら自由度も高く, 疑似的に自分たち専用のサーバーを立てることができるため, 近年は非常に利用が広がっている.

### 負荷分散
- 冗長化によって Webサーバーを増やすことは耐障害性を高めるだけでなく, 負荷分散にもなる.
- 負荷分散はロードバランサーによって実現可能だが, 方式はいくつかに分かれる.
  - **ラウンドロビン方式**：各サーバーに順番にリクエストを振り分ける方式. リクエストの処理の重さによっては負荷に偏りが出る場合がある.
  - **動的分散方式**：サーバーの負荷を監視し, 負荷かが少ないサーバーに優先的にリクエストを振り分ける方式.
  - **パーシステンス**：ログインして利用するようなサービスは Webサーバーが異なるとセッション管理がしにくい. それに対応するために, 同一ユーザーであれば同一サーバーで処理をするように振り分ける方式.

### サーバー設計・構築
- サーバーは個々のサーバーとして耐障害性やセキュリティを高める必要性がある.
  - **ディスク構成**
    - バックアップ用データなどはサーバーのシステムディスクと別ディスクに保管しておくことで, メインディスクが破損した場合にも備えることができる.
    - ディスクが1つしかない場合でも, **パーティショニング**により, 1つのディスクを内部で分割することができる.
  - セキュリティ
    - OS の初期設定などに含まれる初期ユーザーの情報などは使用しないのであれば削除しておくこと.
- **システム基盤テスト**
  - サーバー設定が完了後, 設定ファイルの記載や削除したユーザーでログインできないこと, ミドルウェアの動作確認などをチェックする.

### データベース設計
#### 論理設計
- データベースに格納するべきデータの洗い出しとそのデータ同士の関連性を定義する.
  - つまり, エンティティを洗い出し, データのリレーションを列挙し, エンティティに属する属性を洗い出し, データの重複を削除することでエンティティが最小構成になるように分割することである.

#### 物理設計
- 論理設計で定義されたデータを, 実際にデータベースにどのような形で格納するかを定義する.
  - データ型の検討, 文字コードの検討, ディスク領域の割り当て, インデックスの付加, など.

### アプリケーション設計
- 提供するサービスの内容から基本設計, 詳細設計, それに基づくプログラミングを行う.
- **基本設計（外部設計）**
  - 提供したいサービスを実現するために, アプリケーションがどういった動作をするかを決定する.
  - e.g. 画面レイアウト, 機能の一覧, アプリケーションの構成（モジュールの構成）など.
- **詳細設計（内部設計）**
  - 基本設計を実現するために, どのような**モジュール**が存在すればよいかを決定する.
  - e.g. モジュールの処理内容, モジュール間の連携方法, 画面の遷移など.
- **テスト**
  - モジュールごとに詳細設計に従っているかをテストする**単体テスト**, モジュール同士が結合してうまく基本設計通りに動くかをテストする**連結テスト**がある.

### バックアップ運用
